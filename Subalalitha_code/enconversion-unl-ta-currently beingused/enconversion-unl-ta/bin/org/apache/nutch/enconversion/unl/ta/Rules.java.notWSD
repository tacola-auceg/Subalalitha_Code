package org.apache.nutch.enconversion.unl.ta;
import org.apache.nutch.analysis.unl.ta.Analyser;
import java.lang.*;
import java.util.*;
import java.io.*;

public class Rules{

	MWDict mwdict;
	UWDict uwdict;
	
	BSTNode bn;
	BST dict;
	
	MWBST dict_mw;
	MWBSTNode bn_mw;
	
	ArrayList anal;
	ArrayList wordAL;
	ArrayList root;
	ArrayList rootnew;
	ArrayList pos;
	ArrayList rootrel;
	
	ArrayList abbwords=new ArrayList();
	ArrayList expwords=new ArrayList();
	
	ArrayList tempcmtw;
	ArrayList tempcmew;
	ArrayList tempcmuw;
	
	ArrayList hw;
	ArrayList uw;
	ArrayList no;
	ArrayList conceptfrm;
	ArrayList relnlabel;
	ArrayList conceptto;
	ArrayList compdid;
	
	int aojindex;
	int plfindex;
	int insindex;
	int cobindex;
	int timindex;
	int cwindex;
	int verbcount;
	
	String verb1;
	String verb2;
	String verb3;
	
	boolean bolverb1;
	boolean bolverb2;
	boolean bolverb3;
	
	String verbno1;
	String verbno2;
	String verbno3;
	
	boolean pr_res;
	String pr;
	int pr_index;
	
	String firstword="";
	String firstwordpss="";
	
	int noofcw;
	
	int j=0,total;

	int cnt1 = 0, cnt2 = 0,cnt3 = 0, cnt4 = 0, cnt5 = 0;

   	String analysed;
    	String tempword;

   	String rel_label;
   	String h_word=" ";
   	String u_word = " ";
	
	String result="";

	public String rootentry = null;
	public String uwentry = null;
	public String hwentry = null;


	public String prevanal = null;
	public String curranal = null;
	public String nextanal = null;
	public String prevhw = null;
	public String nexthw = null;
	public String prevuw = null;
	public String nextuw = null;
	public String prevconcept = null;
	public String nextconcept = null;
	
	ArrayList<String> tne = new ArrayList<String>();
	ArrayList<String> uwlist; 
	ArrayList<String> hwlist ;
	ArrayList<String> rootlist;
	ArrayList<String> fentry;
	ArrayList<String> sense;

	//clia.unl.wordsense.WordSense ws;
	
	public String sword="";	
	public String sente="";
	
	public Rules()
	{
		try
    	{
    	   	dict = new BST();
		dict_mw = new MWBST();
		mwdict = new MWDict();
  	   	mwdict.mwbst.inorder();			
    	   	
    		uwdict = new UWDict();
    	   	uwdict.bst.inorder();	 	   	
    	  
		//ws = new WordSense();

    	   	dict = uwdict.bst;
    	   	dict_mw = mwdict.mwbst;

    	   	bn_mw = new MWBSTNode();
    	 }
    	 catch(Exception e)
    	 {
    	 
    	 }
    	 	
    }
   
   public void init()
{
	try
    {

    	anal = new ArrayList();
    	wordAL=new ArrayList();
    	root= new ArrayList();
    	rootnew = new ArrayList();
    	pos = new ArrayList();

    	rootrel = new ArrayList();

    	tempcmtw = new ArrayList();
    	tempcmew = new ArrayList();
    	tempcmuw = new ArrayList();

        hw=new ArrayList();
    	uw = new ArrayList();
    	no = new ArrayList();

    	conceptfrm = new ArrayList();
    	relnlabel = new ArrayList();
    	conceptto = new ArrayList();
    	compdid = new ArrayList();

	uwlist = new ArrayList<String>();
	hwlist = new ArrayList<String>();
	rootlist = new ArrayList<String>();
	fentry = new ArrayList<String>();
	sense = new ArrayList<String>();

    	aojindex = 0;
	insindex = 0;
    	plfindex = 0;
	timindex = 0;
	cobindex = 0;

    	cwindex=0;
    	noofcw = 0;

        bolverb1=false;
    	bolverb2=false;
    	bolverb3=false;

    	pr_res=false;
    	pr="";
    	pr_index = -1;

    	verb1 = "";
    	verb2 = "";
    	verb3 = "";

    	String verbno1=" ";
    	result="[s]#";

   }
   catch(Exception e)
   {
   	
   }
}
public String enconvert(String st)
{
    	try
    	{
    		int cnt=1;
        		String templex="";
       		int flag=0;
        	int now =0;	
				
		//no. of words is initialized to zero
        	//To initialize all array list, variables...
	        	init();

       //Identify words delimiter

        		StringTokenizer inp = new StringTokenizer(st,",; ");
        		sente =  st;
        	int noofwords = inp.countTokens();			// No. of words in the given input
        	int ctnoofwords=0;							//Count no. of words is initialized to zero

	     //store the words in inp array List and root words in root array List

    	    	while(ctnoofwords < noofwords)			//Check the condition
            	{

	       		String word = inp.nextToken().trim(); // Remove the blank spaces in front and back of the sentence using trim().
    	        		String pss="";
       	        		String word2="";
       	     		String word1="";
            			String prev,next;

          //to add root word in wordAL arrayList
	        		wordAL.add(word);

          //analyze the given word

	        		String analysed  =	org.apache.nutch.analysis.unl.ta.Analyser.analyseF(word,true);
	  		StringTokenizer strToken2 = new StringTokenizer(analysed, ":\n<>,=*;:?-'\"&",false);
    	       
        		int firstindex= analysed.indexOf('<',analysed.indexOf('>'));
        			String analmod = analysed.substring(firstindex);
            	//to store analyzer output
            			anal.add(analmod);
		//to get root word and POS from analyzer output
	        	if((analysed.indexOf("unknown") != -1) || (analysed.indexOf("count=4") != -1))
			{			
				word1 = strToken2.nextToken().trim();
				word2 = word1;
				pos.add("None");
				root.add(word2);
			}
			else if ((analysed.indexOf("Adjectival Noun") != -1) || (analysed.indexOf("Noun") != -1) ||(analysed.indexOf("Interrogative") != -1)  || (analysed.indexOf("Non Tamil Noun") != -1)|| (analysed.indexOf("Entity") !=-1) || (analysed.indexOf("Adverb") != -1) || (analysed.indexOf("Numbers") != -1) || (analysed.indexOf("charNumbers") != -1) || (analysed.indexOf("DateTime") != -1) || (analysed.indexOf("Postposition") != -1) ||((analysed.indexOf("Verb") != -1)&&(analysed.indexOf("Finite Verb")== -1))|| (analysed.indexOf("Particle") != -1) || (analysed.indexOf("Adjective") != -1))
			{
				prev = strToken2.nextToken().trim();
				word1 = prev;
				next = strToken2.nextToken().trim();	
				////////////System.out.println("NEXT:"+next);			
				while(strToken2.hasMoreTokens())
				{
					if ( (!(next.equals("Adjectival Noun"))) && (!(next.equals("Noun"))) && (!(next.equals("Interrogative Adjective"))) && (!(next.equals("Interrogative Noun"))) && (!(next.equals("Non Tamil Noun"))) && (!(next.equals("Entity"))) && (!(next.equals("Adverb"))) && (!(next.equals("Numbers"))) && (!(next.equals("charNumbers"))) && (!(next.equals("DateTime"))) && (!(next.equals("Postposition"))) && (!(next.equals("Verb"))) && (!(next.equals("Finite Verb"))) && (!(next.equals("Adjective"))) && ((!(next.equals("Particle")))))
					{
						prev = next;
						next = strToken2.nextToken().trim();
						////////////System.out.println("The VB is"+next);
					}
					else
					{
						break;
					}
				}
				word2 = prev;
				pss = next;
				if(word1.indexOf("இங்கு")!=-1)
            	    		{
				   	processPronoun(word1,ctnoofwords,firstwordpss,analmod);
                		}
                		else
                		{
                	  			root.add(word2);
                	   			pos.add(pss);
                		}
			} 
			else
			{
				word1 = strToken2.nextToken().trim();
				word2 = strToken2.nextToken().trim();
				pss = strToken2.nextToken().trim();
				if((pss.equals("Pronoun")) || (word1.indexOf("இதன்")!=-1)) //ithan, ithu
    	        		{
        	        				processPronoun(word1,ctnoofwords,firstwordpss,analmod);	
    	            		}
				else
				{
				  	root.add(word2);
        	        				pos.add(pss);
            	    		}
            	 	} // end of else
		 	if((pss.equals("Verb")) || (pss.equals("Finite Verb")))
             	 	{
				verbcount++;
                			flag = 0;
				if(bolverb1==false)
                		{
                				bolverb1 = true;
                				verb1 = word2;
                		}
                		else if((bolverb1==true) && (bolverb2 == false))
                		{
                				bolverb2 = true;
                				verb2 = word2;              
                		}
                		else if((bolverb1==true) && (bolverb2==true) && (bolverb3 ==false))
                		{
                				bolverb3 = true;
                	   			verb3 = word2;                 
                		}
             	 	} // end of if
              	 	else
              		{
              			if(flag == 0)
              			{
                			int hc = word2.hashCode();
					////////////System.out.println("Hc  + Word2:"+hc +" "+word2);	
                		//Set the unique value for the word using the Hashcode to search the word in the dictionary using the keyvalue
                	    		if( (bn_mw = dict_mw.search(hc)) != null) // Condition is checked
                	    		{
                	    			////////////System.out.println("Matching");
				                	flag = 1;
                  					cnt++;
	                	    			now =bn_mw.no_words;
	                	    			templex += word2 + " ";
    	        	        	}
	        	         }
	        	         else if((flag == 1) && (cnt < now))
    	        	     	{
        	           				cnt++;
            	       				templex +=word2 + " ";            	       	
            		     	}
	        	        else if((flag==1) && (cnt == now))
    	        	     	{
        	            				templex +=word2;
   	                	        multiwordCheck(templex,bn_mw,cnt,now,pss,analmod);
                  				templex="";
                  				cnt=1;
                   				flag=0;
                	  	 } //end of else if
	                } // end of else
			sword=word2;
              	 	////////////System.out.println("SWORD:"+sword);
              	 	//ws.disambiguate(sword,bn,dict,sente);  
			ctnoofwords++;
        	} // end of while
		for(int i=0;i<pos.size();i++)
		{
			String s=pos.get(i).toString();
			////////////System.out.println("The output of POS"+s);
		}
        	findUW();
    		if(bolverb1 == true)
        	verbno1 = findverbnumber(verb1);
        	firstword=root.get(0).toString(); // to keep track of prev first word for PR
		firstwordpss=pos.get(0).toString();
       		findrelnindex();
       	}
	catch(Exception e)
	{
		e.printStackTrace();
        }
    	return result;
}
  	
  	public void loadequ()
	{
		String equentry="";
    		try
   		 {
    			BufferedReader in = new BufferedReader(new FileReader("./resource/unl/equ.txt"));
		    	while((equentry=in.readLine()) !=null)
    			{
		    	    StringTokenizer tok = new StringTokenizer(equentry,"/");
        		    abbwords.add(tok.nextToken());
        		    expwords.add(tok.nextToken());
        		}
        		in.close();	
		}
		catch(Exception e)
    		{
    
    		}

	}
	public void findUW() {

		int count = 1;
		int cnt=0;
		// String uwentry;
		String rword = "";
		ArrayList<String> te = new ArrayList<String>();
		// StringBuffer sb = new StringBuffer();
		StringBuffer resultuw = new StringBuffer();
		int j = 0,total;

		try {
			total = root.size();
			while (j < total) {
				// int cw_prindex = -1;
				bn = new BSTNode();
				////System.out.println("FindUW root:"+root);
				rword = root.get(j).toString().trim();
				////System.out.println("FindUW rword:"+rword);
				analysed = anal.get(j).toString().trim();
				////System.out.println("FindUW analysed:"+analysed);
				int hc = rword.hashCode();
				int cindex = tempcmtw.indexOf(rword);
				if (cindex >= 0) {
					hw.add(tempcmew.get(cindex).toString());
					uw.add(tempcmuw.get(cindex).toString());
					no.add(new Integer(count++));
					rootnew.add(rword);
				} else if ((bn = dict.search(hc)) != null) {
					////System.out.println("bn root:"+rword);
					////System.out.println("bn uw:"+uw);
					
					BSTNode bnode = new BSTNode();
					bnode = bn;
					
					if(bnode.next != null){
						te = disambiguate(rword, analysed, sente);
						////System.out.println("TE:"+te);
						////System.out.println("RWORD:"+rword);
						cnt = te.indexOf(rword);
						////System.out.println("CNT:"+cnt);
						if(cnt != -1){
							hw.add(te.get(cnt+1).toString());
							uw.add(te.get(cnt+2).toString());
							no.add(new Integer(count++));
							rootnew.add(rword);
						}else if (cnt == -1){
							hw.add(bnode.headword);
							uw.add(bnode.constraint);
							no.add(new Integer(count++));
							rootnew.add(rword);
						}
				//	te.clear();	
				//	te = wsd.AmbiguousRules(rword, analysed);					
					}else{			
						hw.add(bnode.headword);
						uw.add(bnode.constraint);
						no.add(new Integer(count++));
						rootnew.add(rword);
					}
				//	no.add(new Integer(count++));
				} else if (pos.get(j).equals("Numbers")) {

					hw.add(rword);
					uw.add("icl>number");
					no.add(new Integer(count++));
					rootnew.add(rword);
				} else {
					rootnew.add("None");
					hw.add("None");
					uw.add("None");
					no.add("None");
				}
				j++;
			}// end of while
			
			// to append all concepts

			for (int k = 0; k < hw.size(); k++) {
				if (!(rootnew.get(k).equals("None"))) {

					resultuw.append(rootnew.get(k).toString() + ';');
					resultuw.append(hw.get(k).toString() + ';');
					resultuw.append(uw.get(k).toString() + ';');

					resultuw.append(pos.get(k).toString() + ';');
					resultuw.append(no.get(k).toString() + '#');
					// resultuw.append(fcount.get(k).toString()+';');
				}
			}
			result += "[w]#";
			result += resultuw;
			result += "[/w]#";

		} catch (Exception e) {
		}
		
	}
	public ArrayList<String> disambiguate(String sword,String analValue, String sente){ 
	
		try{
				while(bn != null){
				//	////System.out.println("bn1:"+bn.lexeme+"/"+bn.headword+"/"+bn.constraint);
					rootlist.add(bn.lexeme);
					hwlist.add(bn.headword);
					uwlist.add(bn.constraint);
				
					bn = bn.getNext();
				}
				sense = RulesSet(sword);			
		}
		catch(Exception e){
			
		}
		return sense;
	//	sense.clear();
	}
	public void NoRules(String sword){
	//	int i=0;
		
		for(int i=0;i<rootlist.size();i++){
		//	i = rootlist.indexOf(sword);
		if(sword.equals(rootlist.get(i).toString())){
			fentry.add(sword);
			fentry.add(hwlist.get(i).toString());
			fentry.add(uwlist.get(i).toString());
		//	break;
			}	
		}
	}
	public void VerbRule(String sword){
		int j = 0;
		for(int i=0;i<rootlist.size();i++){
		//	////System.out.println("VerbRule");
			rootentry = rootlist.get(i).toString();
			if(rootentry.equals(sword)){
				j = rootlist.indexOf(sword);
				uwentry = uwlist.get(j).toString();
				if(uwentry.contains("action")){
			//	////System.out.println("Verb Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(j).toString());
				fentry.add(uwlist.get(j).toString());
				}
			}		
		}		
	}
	public void NumberSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			//	////System.out.println("NumberRule");
				uwentry = uwlist.get(i).toString();
				if(uwentry.contains("number")){
			//		////System.out.println("Number Sense:"+uwentry);
					fentry.add(sword);
					fentry.add(hwlist.get(i).toString());
					fentry.add(uwentry);
				}			
		}//////System.out.println("NumberRule fentry:"+fentry);
	}
	public void NotNumberSense(String sword){
		int ind = rootlist.indexOf(sword);
		if(!(uwlist.get(ind).toString().contains("number"))){
			if(!(uwlist.get(ind+1).toString().contains("number"))){
			//	////System.out.println("NotNumberSense:"+sword);
				fentry.add(sword);
				fentry.add(hwlist.get(ind).toString());
				fentry.add(uwlist.get(ind).toString());
			}
		}
	}
	public void PositionSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if(uwentry.contains("position")){
			//	////System.out.println("Position Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}	
	} 
	public void OfferSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if( (uwentry.contains("offer")) || (uwentry.contains("food")) ){
			//	////System.out.println("Offer Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}
	}
	public void PlaceSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			hwentry = hwlist.get(i).toString();
			if( (uwentry.contains("money")) || (uwentry.contains("river")) || (uwentry.contains("person")) || (uwentry.contains("weapon")) || (hwentry.contains("place")) ){
			//	////System.out.println("Offer Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwlist.get(i).toString());
			}
		}
	}
	public void MonthSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if( (uwentry.contains("month")) || (uwentry.contains("day")) ){
			//	////System.out.println("month Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}	
	}
	public void RiverSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if( (uwentry.contains("river")) || (uwentry.contains("day")) ){
			//	////System.out.println("river Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}
	}
	public void UnitSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			hwentry = hwlist.get(i).toString();
			if( (uwentry.contains("unit")) || (uwentry.contains("number")) ||(uwentry.contains("measurement")) || (uwentry.contains("time")) || (uwentry.contains("mountain")) || (hwentry.contains("first"))){
			//	////System.out.println("unit Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}
	}
	public void StyleSense(String sword){
	//	////System.out.println("Sword::uwentry:"+sword);
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if( (uwentry.contains("style")) || (uwentry.contains("number")) || (uwentry.contains("book")) || (uwentry.contains("document")) ){
			//	////System.out.println("style or number Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}
	}
	public void GodPersonSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			int ind = rootlist.indexOf(sword);
			if( (uwentry.contains("god")) ||(uwentry.contains("goddess")) ){				
			//	////System.out.println("god or person Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(ind).toString());
				fentry.add(uwlist.get(ind).toString());
			}
		}
	}
	public void ColorSense(String sword){
		for(int i=0;i<uwlist.size();i++){
			uwentry = uwlist.get(i).toString();
			if(uwentry.contains("color")){
			//	////System.out.println("color Sense:"+uwentry);
				fentry.add(sword);
				fentry.add(hwlist.get(i).toString());
				fentry.add(uwentry);
			}
		}
	}
	public void getFirsthit(String sword){
		int hc = sword.hashCode();
	//	////System.out.println("Inside getFirsthhit");
		if((bn = dict.search(hc)) != null){
			fentry.add(sword);
			fentry.add(bn.headword);
			fentry.add(bn.constraint);
		}
	}
	public ArrayList<String> RulesSet(String sword){
		
	//	////System.out.println("Inside RULES SET");
	//	////System.out.println("sword:"+sword);
		int k = 0;
		k = root.indexOf(sword);
	//	////System.out.println("k:"+k);
		curranal = anal.get(k).toString();
	//	////System.out.println("curranal:"+curranal);
		if(k == 0){
			getFirsthit(sword);
		}else if(k>0){
			prevconcept = root.get(k-1).toString();
			prevanal = anal.get(k-1).toString();
		//	////System.out.println("prevanal:"+prevanal);
			prevhw = hw.get(k-1).toString();
			prevuw = uw.get(k-1).toString();
		//	////System.out.println("prevuw:"+prevuw);
		//	////System.out.println("k::++ root::"+k+"="+(root.size()-1));
			if(k < (root.size()-1)){
				
				nextanal = anal.get(k+1).toString();
			//	////System.out.println("nextanal:"+nextanal);
			//	nextuw = uw.get(k+1).toString();
			//	////System.out.println("nextuw:"+nextuw);
			}
		
	
			if(curranal.indexOf("Verb")!=-1){
				VerbRule(sword);
			}else if((prevuw.contains("document")) || (prevuw.contains("book")) || (prevuw.contains("language")) ){
				StyleSense(sword);	
			}else if(nextanal.indexOf("Plural Suffix") != -1){
				NumberSense(sword);
				NotNumberSense(sword);
			}else if(prevanal.indexOf("ஆவது") != -1){
				PositionSense(sword);
			}else if(prevuw.indexOf("food") != -1){
				OfferSense(sword);
			}else if( (prevuw.indexOf("month") != -1) || (prevuw.indexOf("day") != -1) ){ //|| (nextuw.indexOf("month") != -1) || (nextuw.indexOf("day") != -1) ){
				MonthSense(sword);
		/**	}else if(prevanal.indexOf("Adjective") != -1){
				RiverSense(sword);  */
			}else if( (prevanal.indexOf("Numbers") != -1) || (prevanal.indexOf("charNumbers") != -1) ){
				UnitSense(sword);
			}else if( (prevanal.indexOf("Entity") != -1) || (prevuw.contains("number")) || (prevuw.contains("period")) || (prevuw.contains("building")) ||(prevhw.contains("place")) ){
				PlaceSense(sword);
			}else if( (prevuw.contains("god")) || (prevuw.contains("goddess")) ){ //  || (nextuw.contains("god"))){
				GodPersonSense(sword);
		/**	}else if( (prevuw.contains("person")) ){ //|| (nextuw.contains("person")) ){
				GodPersonSense(sword); */
			}else if( (prevuw.contains("color")) ){ //|| (nextuw.contains("attribute")) ){
				ColorSense(sword); 
			}else if(prevconcept.equals("பெரிய")){
				RiverSense(sword);
			}else{
				int hc = sword.hashCode();
			//	////System.out.println("hc:"+hc+":"+sword);
				if( (bn = dict.search(hc)) != null){
			//		////System.out.println("WSD INSIDE BST");
			//		////System.out.println("bn.lexeme:"+bn.lexeme);
					fentry.add(sword);
					fentry.add(bn.headword);
					fentry.add(bn.constraint);
				} 	
			//	getFirsthit(sword);
			}
		}
			////System.out.println("RulesSet:"+fentry);
			return fentry;
	/**	}catch(Exception e){
			e.printStackTrace();
		}*/
	}
public String findverbnumber(String v)
{
    int tempindex;
    int totalrw;

    int totrw=root.size();


	try
	{
        tempindex=root.indexOf(v.trim());

        if(tempindex != -1)
            return(no.get(tempindex).toString().trim());

    }

     catch(Exception e)
    {

    }
    return("0");
}
// To check the Multiwords in the given document.

public void multiwordCheck(String templex,MWBSTNode bn_mw,int cnt,int now,String pss,String analmod)
{	
	String lex =   bn_mw.lexeme;
	////////////System.out.println("JKB JKB MULTIWORDCHECK **8.8.8"+lex);
	////////////System.out.println("BALAJI Templex 8.8.8"+templex);
    	if(lex.equals(templex))
	{
     		for(int p=1;p<=cnt;p++)
     		{
           			wordAL.remove(wordAL.size() - 1);
           			anal.remove(anal.size() -1);
           			root.remove(root.size() -1);
           			pos.remove(pos.size() -1);
     		}
   	 	wordAL.add(bn_mw.lexeme);
     		root.add(bn_mw.lexeme);
     		pos.add(pss);
     		anal.add(analmod);

     		tempcmtw.add(bn_mw.lexeme);
     		tempcmew.add(bn_mw.headword);
     		tempcmuw.add(bn_mw.constraint);

     		return ;
	}
	else
    {
     if(bn_mw.next == null)
   	 {
      	return ;
   	 }
        //if more than one mwe contains same fw
   	else
   	{
	  	int tok_cnt =now;
   
        while(bn_mw.next != null)
        {
           	MWBSTNode temp = new MWBSTNode();
			String next_lex= " ";
			temp = bn_mw.next;
			bn_mw = bn_mw.next;
			
			int next_cnt = temp.no_words;
			StringBuffer sb_mw = new StringBuffer();
			
			if(next_cnt == tok_cnt)
			{
			 	next_lex = temp.lexeme;
			}
			else if(next_cnt < tok_cnt)
            {
              	String temp_lexeme = "";
                next_lex = temp.lexeme;

                while(next_cnt != tok_cnt)
                {
					int index = templex.lastIndexOf(" ");
					temp_lexeme = templex.substring(0,index).trim();
					sb_mw.insert(0," "+templex.substring(index+1,templex.length()));
			
					templex = temp_lexeme;
					tok_cnt = tok_cnt -1 ;
                }
             }
             if(next_lex.equals(templex))
             {
                for(int p=1;p<=cnt;p++)
               	{
               		wordAL.remove(wordAL.size() - 1);
             		root.remove(root.size() - 1);
               		pos.remove(pos.size() - 1);
               		anal.remove(anal.size() -1);
               	}
        		wordAL.add(temp.lexeme);
         		root.add(temp.lexeme);
         		anal.add(analmod);
         		pos.add(pss);

           		tempcmtw.add(temp.lexeme);
           		tempcmew.add(temp.headword);
          		tempcmuw.add(temp.constraint);

          		//to add remaining words in the framed temporary muli words

           		if(sb_mw.length() > 1)
          		{
         			StringTokenizer st1_mw = new StringTokenizer(sb_mw.toString());
          			while(st1_mw.hasMoreTokens())
           			{
        				String temp_tok;
           				temp_tok = st1_mw.nextToken();
	     				root.add(temp_tok);
          				wordAL.add(temp_tok);
           				anal.add(analmod);
    	  				pos.add(pss);
           			}
         			sb_mw.delete(0,sb_mw.length());
        		}
           		return ;
        	}
     	}
	}
    return ;
 }
}
public void multiwordCheck1(String templex,MWBSTNode bn_mw,int cnt,int now,String pss,String analmod)
{	
	String lex =   bn_mw.lexeme;
	////////////System.out.println("JKB JKB MULTIWORDCHECK **8.8.8"+lex);
	////////////System.out.println("BALAJI Templex 8.8.8"+templex);
    	if(lex.equals(templex))
	{
     	 	wordAL.add(bn_mw.lexeme);
     		root.add(bn_mw.lexeme);
     		pos.add(pss);
     		anal.add(analmod);

     		tempcmtw.add(bn_mw.lexeme);
     		tempcmew.add(bn_mw.headword);
     		tempcmuw.add(bn_mw.constraint);

     		return ;
	}
	else
    	{
     /*if(bn_mw.next == null)
   	 {
      	return ;
   	 }
        //if more than one mwe contains same fw
   	else
   	{
	  	int tok_cnt =now;
   
        while(bn_mw.next != null)
        {
           	MWBSTNode temp = new MWBSTNode();
			String next_lex= " ";
			temp = bn_mw.next;
			bn_mw = bn_mw.next;
			
			int next_cnt = temp.no_words;
			StringBuffer sb_mw = new StringBuffer();
			
			if(next_cnt == tok_cnt)
			{
			 	next_lex = temp.lexeme;
			}
			else if(next_cnt < tok_cnt)
            {
              	String temp_lexeme = "";
                next_lex = temp.lexeme;

                while(next_cnt != tok_cnt)
                {
					int index = templex.lastIndexOf(" ");
					temp_lexeme = templex.substring(0,index).trim();
					sb_mw.insert(0," "+templex.substring(index+1,templex.length()));
			
					templex = temp_lexeme;
					tok_cnt = tok_cnt -1 ;
                }
             }
             if(next_lex.equals(templex))
             {
                for(int p=1;p<=cnt;p++)
               	{
               		wordAL.remove(wordAL.size() - 1);
             		root.remove(root.size() - 1);
               		pos.remove(pos.size() - 1);
               		anal.remove(anal.size() -1);
               	}
        		wordAL.add(temp.lexeme);
         		root.add(temp.lexeme);
         		anal.add(analmod);
         		pos.add(pss);

           		tempcmtw.add(temp.lexeme);
           		tempcmew.add(temp.headword);
          		tempcmuw.add(temp.constraint);

          		//to add remaining words in the framed temporary muli words

           		if(sb_mw.length() > 1)
          		{
         			StringTokenizer st1_mw = new StringTokenizer(sb_mw.toString());
          			while(st1_mw.hasMoreTokens())
           			{
        				String temp_tok;
           				temp_tok = st1_mw.nextToken();
	     				root.add(temp_tok);
          				wordAL.add(temp_tok);
           				anal.add(analmod);
    	  				pos.add(pss);
           			}
         			sb_mw.delete(0,sb_mw.length());
        		}
           		return ;
        	}
     	}
	}
    return ;*/
 }
}

public void processPronoun(String word1,int ctnoofwords,String pss,String analmod)
{
	 
	  pr_res = true;
      pr = word1;
      pr_index = ctnoofwords;

     
      root.add(firstword);
      pos.add(firstwordpss);

      StringTokenizer pr_tok = new StringTokenizer(firstword);
       if(pr_tok.countTokens() > 1)
       {
     
      		int now = pr_tok.countTokens();
      		int hc = (pr_tok.nextToken()).hashCode();
       		if( (bn_mw = dict_mw.search(hc)) != null)
      		{
       			multiwordCheck(firstword,bn_mw,1,now,pss,analmod);
             }

       	}
	}
   
  
 /** Various Rules are defined for UNL Relations. 
 * Rule1 is defined for the UNL relations:
 *  frm, 
 *  plf,
 *  src,
 *  tmf.
 *  Based on the UNL Constraints the relations will vary. 
 *  These relations are obtained by applying the 
 *  Rule: <"இல்", "ஆக", "இடம்">-> <"இருந்து">
 */
	public void Rule1() 
	{
		rootrel.set(j, "frm");
		rel_label = "plf";
		findRelation_Category5(j + 1, j, rel_label);
		if ((j + 1) != total) {
			String anal2 = anal.get(j + 1).toString().trim();

			if (anal2.indexOf("Relative Participle") != -1) {
				u_word = uw.get(j).toString();
				if ((u_word.indexOf("place") != -1)
						|| (u_word.indexOf("city") != -1)
						|| (u_word.indexOf("district") != -1)
						|| (u_word.indexOf("organization") != -1)
						|| (u_word.indexOf("temple") != -1)
						|| (u_word.indexOf("facilities") != -1)
						|| (u_word.indexOf("country") != -1)
						|| (u_word.indexOf("lake") != -1)
						|| (u_word.indexOf("vehicle") != -1)
						|| (u_word.indexOf("body") != -1)) {
					rootrel.set(j, "frm");
					rel_label = "frm";
					findRelation_Category5(j + 1, j, rel_label);
				}
			} else {
				plfindex = j;
				rootrel.set(j, "plf" + "src");
				u_word = uw.get(j).toString();
				if ((u_word.indexOf("place") != -1)
						|| (u_word.indexOf("city") != -1)
						|| (u_word.indexOf("district") != -1)
						|| (u_word.indexOf("organization") != -1)
						|| (u_word.indexOf("temple") != -1)
						|| (u_word.indexOf("facilities") != -1)
						|| (u_word.indexOf("country") != -1)
						|| (u_word.indexOf("lake") != -1)) {
					rel_label = "plf";
				} else if (u_word.indexOf("time") != -1) {
					rel_label = "tmf";
				} else if (u_word.indexOf("event") != -1) {
					rel_label = "scn";
				} else {
				//	rel_label = "src";
				}
				findRelation_Category2(j, rel_label);
			}
		}
	}
	/**Rule2 is defined for the UNL Relation:
	 * 'and'.
	 * The 'and' relation is obtained by the following rules 
	 * applied: "மட்டுமல்லாமல்", "மற்றும்", "மேலும்", "உம்".
	 * 
	 */

	public void Rule2() // mattumallamal
	{
		// flag2=1;
		rootrel.set(j, "and");
		rel_label = "and";
		findRelation_Category1(j, rel_label);
	}
	
	/** Rule3 is defined for the UNL Relation:
	 * ' via'
	 * The 'via'relation is obtained by applying the 
	 * Rule: "வழியாக"
	 */

	public void Rule3() // Valiyaga
	{
		rootrel.set(j, "via");
	//	rel_label = "via";
	//	findRelation_Category4(j, rel_label);
		u_word = uw.get(j - 1).toString();		
		if ((u_word.indexOf("place") != -1)
				|| (u_word.indexOf("city") != -1)
				|| (u_word.indexOf("district") != -1)
				|| (u_word.indexOf("organization") != -1)
				|| (u_word.indexOf("temple") != -1)
				|| (u_word.indexOf("facilities") != -1)
				|| (u_word.indexOf("country") != -1)
				|| (u_word.indexOf("lake") != -1)) {
		
			rel_label = "via";
		//	rootrel.set(j, "via");
			findRelation_Category4(j, rel_label);
		}

	}
	/** Rule4 is defined for the UNL Relation:
	 * 'and'
	 * 'ptn'.
	 * The 'and' and 'ptn' relations are obtained by the following
	 * Rule: "உம்" and the position of the analysed string.
	 */
	
	public void Rule4() {

		String pos1 = pos.get(j).toString();
		if ((j + 1) != total) {
			String pos2 = pos.get(j + 1).toString();
			String anal2 = anal.get(j + 1).toString().trim();
			if ((pos1.equals(pos2)) && (anal2.indexOf("உம்") != -1)) {
				rootrel.set(j, "and" + "ptn");
				rel_label = "ptn";
				findRelation_Category3(j + 1, rel_label);

				rel_label = "and";
				findRelation_Category5(j + 1, j, rel_label);
			}
		}
	}
	/**Rule5 is defined for the UNL Realtion:
	 * 'agt'.
	 * The 'agt' relation is obtained by checking the Instrumental case (i.e. 'ins'relation)
	 * The Rule for 'agt' reltion is "படு","அது". 
	 * The "insindex" Rule is "ஆல்".
	 */
		
	public void Rule5() {

		if (insindex == 1) {
			int i = rootrel.indexOf("ins");
			u_word = uw.get(i).toString();
			if ((u_word.indexOf("person") != -1)
					|| (u_word.indexOf("name") != -1)
					|| (u_word.indexOf("relative") != -1)) {
				rootrel.set(j, "agt");
				rel_label = "agt";
				findRelation_Category2(i, rel_label);
			}
		}
	}
	/** Rule6 is defined for the UNL Relations:
	 * 	'con',
	 *  	'ins',
	 * 	'met'.
	 * 	These relations are obtained by applying the 
	 * 	Rule: "ஆல்"
	 * 	The insindex is set only when the concept is instrument, flower, vechicle etc..
	 * 	The 'con' relation is obtained by checking with the verb.
	 * 	And if the concept is a person, name or relative then the 'met' relation is obtained.  
	 */

	public void Rule6() {

		if (pos.get(j).toString().equals("Verb")) {
			rootrel.set(j, "con");
			rel_label = "con";
			findRelation_Category1(j, rel_label);
		} else {
			insindex = 1;
			rootrel.set(j, "ins");
			u_word = uw.get(j).toString();

			if ((u_word.indexOf("instrument") != -1)
					|| (u_word.indexOf("flower") != -1)
					|| (u_word.indexOf("vehicle") != -1)
					|| (u_word.indexOf("stationery") != -1)
					|| (u_word.indexOf("rock") != -1)) {
				rel_label = "ins";
				findRelation_Category2(j, rel_label);
			} else if ((u_word.indexOf("person") != -1)
					|| (u_word.indexOf("name") != -1)
					|| (u_word.indexOf("relative") != -1)) {
				rel_label = "met";
				findRelation_Category2(j, rel_label);
			}
		}
	}
	/**	Rule7 is defined for the UNL Relation:
	 * 	'plt'.
	 * 	The 'plt' Relation is obtained by applying the
	 * 	Rule: "க்கு"
	 */

	public void Rule7() {
		rootrel.set(j, "plt");
		rel_label = "plt";
		findRelation_Category1(j, rel_label);
	}
	/**	Rule8 is defined for the UNL Relation:
	 * 	'bas'.
	 * 	The 'bas' relation is obtained by applying the
	 * 	Rule: <"காட்டிலும்", "விட">
	 */	
	
	public void Rule8() {

		rootrel.set(j, "bas");
		rel_label = "bas";
		findRelation_Category1(j, rel_label);
	}
	/**	Rule9 is defined for the UNL Relation:
	 * 	'ben'.
	 * 	The 'ben' relation is obtained by applying the 
	 * 	Rule:"உக்கு", "ஆக"
	 *	By Checking the UW word constraint the relation is set to the corresponding concepts. 
	 */

	public void Rule9() {

		rootrel.set(j, "ben");
		u_word = uw.get(j).toString();
		if ((u_word.indexOf("person") != -1) || (u_word.indexOf("place") != -1)
				|| (u_word.indexOf("vehicle") != -1)
				|| (u_word.indexOf("city") != -1)
				|| (u_word.indexOf("district") != -1)
				|| (u_word.indexOf("organization") != -1)
				|| (u_word.indexOf("temple") != -1)
				|| (u_word.indexOf("facilities") != -1)
				|| (u_word.indexOf("country") != -1)
				|| (u_word.indexOf("lake") != -1)
				|| (u_word.indexOf("name") != -1)
				|| (u_word.indexOf("relative") != -1)) {
			rel_label = "ben";
			findRelation_Category2(j, rel_label);
		}
	}
	/**	Rule10 is defined for the UNL Realtions:
	 * 	'cag',
	 * 	'cao',
	 * 	'cob'.
	 * 	These reltions are obtained by setting the codindex and 
	 * 	By applying the Rule: "உடன்", "ஓடு". 
	 */

	public void Rule10() {

		// int cobindex;

		rootrel.set(j, "cag" + "cao" + "cob");
		int cobindex = 1;
		u_word = uw.get(j).toString();

		if ((u_word.indexOf("person") != -1) || (u_word.indexOf("place") != -1)
				|| (u_word.indexOf("vehicle") != -1)
				|| (u_word.indexOf("city") != -1)
				|| (u_word.indexOf("district") != -1)
				|| (u_word.indexOf("organization") != -1)
				|| (u_word.indexOf("temple") != -1)
				|| (u_word.indexOf("facilities") != -1)
				|| (u_word.indexOf("country") != -1)
				|| (u_word.indexOf("lake") != -1)
				|| (u_word.indexOf("name") != -1)
				|| (u_word.indexOf("relative") != -1)) {
			rootrel.set(j, "cag");
			rel_label = "cag";
			findRelation_Category3(j, rel_label);
		} else {
			rel_label = "cao";
			findRelation_Category5(j + 1, j, rel_label);
		}
	}
	/**	Rule11 is defined for the UNL Relation:
	 * 	'cnt'.
	 * 	The 'cnt' Relation  is obtained by applying the 
	 * 	Rule: "என்பது". 
	 */
	
	public void Rule11() {

		rootrel.set(j, "cnt");
		rel_label = "cnt";
		findRelation_Category1(j, rel_label);
	}
	/**	Rule12 is defined for the UNL Relation:
	 * 	'coo'.
	 * 	The 'coo' relation is obtained by applying the 
	 * 	Rule:<"கொண்டே", "அதேவேளை">
	 */

	public void Rule12() {

		rootrel.set(j, "coo");
		rel_label = "coo";
		findRelation_Category1(j, rel_label);
	}
	/**	Rule13 is defined for the UNL Relation:
	 * 	'dur'.
	 * 	The 'dur' relation is obtained by applying the 
	 * 	Rule: <"பொழுது", "போது"> 
	 */

	public void Rule13() {
		rootrel.set(j, "dur");
		rel_label = "dur";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule14 is defined for the UNL Realtion:
	 * 	'equ'.
	 * 	The 'equ' relation is obtained by applying the 
	 * 	Rule:	"என்னும்".
	 */

	public void Rule14() {
		rootrel.set(j, "equ");
		for (int i = 0; i < uw.size(); i++) {
			u_word = uw.get(i).toString();
			if (u_word.indexOf("iof>place") != -1) {
				rel_label = "equ";
				findRelation_Category5(j + 1, i, rel_label);
			}

		}
	}
	/**	Rule15 is defined for the UNL Relation:
	 * 	'plf',
	 * 	'tmf'.
	 * 	These Relations are obtained by applying the following
	 * 	Rules:	<"முதல்", "இருந்து"> 
	 */
	public void Rule15() {
		rootrel.set(j, "plf");
		for (int i = j - 1; i >= 0; i--) {
			u_word = uw.get(i).toString();
			if ((u_word.indexOf("place") != -1)
					|| (u_word.indexOf("city") != -1)
					|| (u_word.indexOf("district") != -1)
					|| (u_word.indexOf("organization") != -1)
					|| (u_word.indexOf("temple") != -1)
					|| (u_word.indexOf("facilities") != -1)
					|| (u_word.indexOf("country") != -1)
					|| (u_word.indexOf("lake") != -1)) {
				plfindex = i;
				rel_label = "plf";
				findRelation_Category2(i, rel_label);
				break;
			} else if ((u_word.indexOf("month") != -1)
					|| (u_word.indexOf("time") != -1)) {
				plfindex = i;
				rel_label = "tmf";
				findRelation_Category2(i, rel_label);
				break;
			}
		}
		/**
		 * if(plfindex > 0) { rel_label = "fmt";
		 * findRelation_Category5(plfindex,i,rel_label); }
		 */
	}
	/**	Rule16 is defined for the UNL Relation:
	 * 	'plt',
	 * 	'gol',
	 * 	'tmt'.
	 * 	These relations are obtained by applying the 
	 * 	Rules: "க்கு".
	 */

	public void Rule16() {

		rootrel.set(j, "plt" + "gol");
		u_word = uw.get(j).toString();
		if ((u_word.indexOf("place") != -1) || (u_word.indexOf("city") != -1)
				|| (u_word.indexOf("district") != -1)
				|| (u_word.indexOf("organization") != -1)
				|| (u_word.indexOf("temple") != -1)
				|| (u_word.indexOf("facilities") != -1)
				|| (u_word.indexOf("country") != -1)
				|| (u_word.indexOf("lake") != -1)) {
			rel_label = "plt";
		} else if ((u_word.indexOf("time") != -1)
				|| (u_word.indexOf("month") != -1)) {
			rel_label = "tmt";
		} else {
			rel_label = "gol";
		}
		findRelation_Category2(j, rel_label);
	}
	/**	Rule17 is defined for the UNL Relation:
	 * 	'plt'
	 * 	The 'plt' relation is obtained by applying the 
	 * 	Rule: "வரை"
	 */
	public void Rule17() {

		rootrel.set(j, "plt");

		for (int i = j - 1; i >= 0; i--) {
			u_word = uw.get(i).toString();
			if ((u_word.indexOf("place") != -1)
					|| (u_word.indexOf("city") != -1)
					|| (u_word.indexOf("district") != -1)
					|| (u_word.indexOf("organization") != -1)
					|| (u_word.indexOf("temple") != -1)
					|| (u_word.indexOf("facilities") != -1)
					|| (u_word.indexOf("country") != -1)
					|| (u_word.indexOf("lake") != -1)) {
				rel_label = "plt";
				findRelation_Category2(i, rel_label);
				break;
			} else if ((u_word.indexOf("time") != -1)
					|| (u_word.indexOf("month") != -1)) {
				rel_label = "tmt";
				findRelation_Category2(i, rel_label);
				break;
			}
		}
		/**
		 * if(plfindex > 0) { rel_label = "fmt";
		 * findRelation_Category5(plfindex,i,rel_label); }
		 */
	}
	/** Rule18 is defined for the UNL Relation:
	 * 	'ins',
	 * 	'obj'.
	 * 	These relations are obtained by applying the 
	 * 	Rule:	"ஐ"
	 */

	public void Rule18() {
		rootrel.set(j, "ins" + "obj");
		u_word = uw.get(j).toString();
		if ((u_word.indexOf("instrument") != -1)
				|| (u_word.indexOf("vehicle") != -1)
				|| (u_word.indexOf("stationery") != -1)) {
			rel_label = "ins";
		} else {
			rel_label = "obj";
		}
		findRelation_Category2(j, rel_label);
	}
	/**	Rule19 is defined for the UNL Relation:
	 * 	'plc'
	 * 	The 'plc' relation is obtained by applying the 
	 * 	Rule: "இங்கு", "அங்கு" with the Pronoun Checking is true.***
	 */
	public void Rule19() {
		rootrel.set(pr_index, "plc");
		rel_label = "plc";
		findRelation_Category4(j, rel_label);
	}
	/** Rule20 is defined for the UNL Relation:
	 * 	'pos'
	 * 	The 'pos' relation is obtained by applying the 
	 * 	Rule:"இன்" 
	 */
	public void Rule20() {
		rootrel.set(j, "pos");
		rel_label = "pos";
		findRelation_Category5(j + 1, j, rel_label);
		// for(int i=j+1;i<total;i++)
		int i = j + 1;
		if (i != total) {
			u_word = uw.get(i).toString();
			if ((u_word.indexOf("place") != -1)
					|| (u_word.indexOf("city") != -1)
					|| (u_word.indexOf("district") != -1)
					|| (u_word.indexOf("organization") != -1)
					|| (u_word.indexOf("temple") != -1)
					|| (u_word.indexOf("facilities") != -1)
					|| (u_word.indexOf("country") != -1)
					|| (u_word.indexOf("lake") != -1)) {
				rootrel.set(i, pos);
				rel_label = "pos";
				findRelation_Category5(i, j, rel_label);
			} else {
				// break;
			}
		}
		i++;
	}
	/**	Rule21 is defined for the UNL Relation:
	 * 	'ins',
	 * 	'met'.
	 * 	These Relations are obtained by applying the 
	 * 	Rules:<"மூலம்","வைத்து","உபயோகி","கொண்டு"> 
	 */
	public void Rule21() {
		rootrel.set(j, "ins");
		u_word = uw.get(j - 1).toString();
		if ((u_word.indexOf("instrument") != -1)
				|| (u_word.indexOf("flower") != -1)
				|| (u_word.indexOf("vehicle") != -1)
				|| (u_word.indexOf("stationery") != -1)) {
			rel_label = "ins";
		} else {
			rel_label = "met";
		}
		findRelation_Category4(j, rel_label);
	}
	/**	Rule22 is defined for the UNL Relation:
	 * 	'int'.
	 * 	The 'int' relation is obtained by applying the 
	 * 	Rule: "பொது".
	 */
	public void Rule22() {

		rootrel.set(j, "int");
		rel_label = "int";
		findRelation_Category5(j - 1, j - 2, rel_label);
	}
	/**	Rule23 is defined for the UNL Relation:
	 * 	'man'.
	 * 	The 'man' relation is obtained by applying the 
	 * 	Rule:"மிக"
	 */

	public void Rule23() {
		rootrel.set(j, "man");
		rel_label = "man";
		findRelation_Category5(j + 1, j, rel_label);
	}
	/**	Rule24 is defined for the UNL Relation:
	 * 	'man' by appling the Rule:"இங்கு" with the Adverb. 
	 */
	public void Rule24() {
		rootrel.set(j, "man");
		rel_label = "man";
		findRelation_Category2(j, rel_label);
	}
	/**	Rule25 is defined for the UNL Relation:
	 * 	'mod' by applying the Rule: Adjective comes as a concept. 
	 */

	public void Rule25() {
		rootrel.set(j, "mod");
		rel_label = "mod";
		findRelation_Category5(j + 1, j, rel_label);
	}
	/**	Rule26 is defined for the UNL Relation:
	 * 	'nam' by applying the Rules:<"ஆகிய","போன்ற","முதலிய">
	 *  and by checking the next word equals  <"இடம்","நாள்","நாடு">
	 */
	public void Rule26() {
		String w1 = root.get(j + 1).toString().trim();

		if ((w1.equals("இடம்")) || (w1.equals("நாள்")) || (w1.equals("நாடு"))) {
			rootrel.set(j, "nam");
			h_word = hw.get(j + 1).toString();
		//	////System.out.println("h_word:1" + h_word);
			for (int i = 0; i < uw.size(); i++) {
				u_word = uw.get(i).toString();
		//		////System.out.println("u_word:1" + u_word);
				if (u_word.indexOf(h_word) != -1) {
					rel_label = "nam";
					findRelation_Category5(j + 1, i, rel_label);
				}

			}
		}
	}
	/**	Rule27 is defined for the UNL Relation:
	 * 	'or'.
	 * 	The Rules applied for the 'OR' relation is:"அல்லது"
	 */
	public void Rule27() {
		rootrel.set(j, "or");
		rel_label = "or";
		findRelation_Category1(j, rel_label);
	}

	public void Rule28() {
		rootrel.set(j, "per");
		rel_label = "per";
		findRelation_Category4(j, rel_label);
	}

	public void Rule29() {
		if ((pos.get(j).toString().equals("Noun"))
				|| (pos.get(j).toString().equals("Entity"))) {
			rootrel.set(j, "pos");
			rel_label = "pos";
			findRelation_Category5(j + 1, j, rel_label);
		} else {
			aojindex = j;
			rel_label = "aoj";
		}
	}

	public void Rule30() {
		if (pos.get(j).toString().equals("Verb")) {
			rootrel.set(j, "pur");
			rel_label = "pur";
			findRelation_Category2(j, rel_label);
		}
	}

	public void Rule31() {
		rootrel.set(j, "qua");
		rel_label = "qua";
		findRelation_Category5(j + 1, j, rel_label);
	}

	public void Rule32() {
		rootrel.set(j, "rsn");
		rel_label = "rsn";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule33 is defined for the UNL Relation:
	 * 	'seq'.
	 * 	The 'seq' relation is obtained by applying the
	 * 	Rule:
	 */
	public void Rule33() {
		rootrel.set(j, "seq");
		rel_label = "seq";
		findRelation_Category1(j, rel_label);
	}

	public void Rule34() {
		timindex = 1;
		rootrel.set(j - 1, "tim");
		u_word = uw.get(j - 1).toString();
		if (u_word.indexOf("number") != -1) {
			rel_label = "tim";
			findRelation_Category4(j, rel_label);
		}
	}

	public void Rule35() {
		rootrel.set(j, "iof");
		h_word = hw.get(j).toString();
		for (int i = 0; i < uw.size(); i++) {
			u_word = uw.get(i).toString();
			if (u_word.indexOf(h_word) != -1) {
				rel_label = "iof";
				findRelation_Category5(j, i, rel_label);			
			}
		}
	}

	public void Rule36() {
		rootrel.set(j, "pof");
		h_word = hw.get(j).toString();
		for (int i = 0; i < uw.size(); i++) {
			u_word = uw.get(i).toString();
			if (u_word.indexOf(h_word) != -1) {
				rel_label = "pof";
				findRelation_Category5(j, i, rel_label);
			}
		}
	}
	/**	Rule37 is defined for the UNL Relation:
	 * 	'aoj'.
	 * 	The 'aoj' relation is obtained by applying the 
	 * 	Rules: <"உள்ளது","இருக்கும்","உள்ளன","நிறைந்தது","ஆகும்","உண்டு", "பற்றி", "பற்றிய">
	 */
	public void Rule37() {
		// flag3=1;
		aojindex = j;
		rootrel.set(j, "aoj");
		rel_label = "aoj";
		findRelation_Category4(j, rel_label);
	}

	public void Rule38() {

		rootrel.set(j, "plc");
		u_word = uw.get(j).toString();
		if (u_word.indexOf("pof<body") != -1) {
			rel_label = "opl";
			findRelation_Category2(j, rel_label);
		} else if ((u_word.indexOf("place") != -1)
				|| (u_word.indexOf("city") != -1)
				|| (u_word.indexOf("district") != -1)
				|| (u_word.indexOf("organization") != -1)
				|| (u_word.indexOf("temple") != -1)
				|| (u_word.indexOf("facilities") != -1)
				|| (u_word.indexOf("country") != -1)
				|| (u_word.indexOf("lake") != -1)) {
			
			rel_label = "plc";				
			findRelation_Category2(j, rel_label);
		} else if (u_word.indexOf("time") != -1) {
			rel_label = "tim";
			findRelation_Category2(j, rel_label);
		}
	}
	/**	Rule39 is defined for the UNL Relation:
	 * 	'neg'.
	 * 	The 'neg' relation is obtained by applying the 
	 * 	Rules:<"அல்லாத","நீங்கலாக">
	 */
	public void Rule39() {
		rootrel.set(j, "neg");
		rel_label = "neg";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule40
	 * 
	 */

	public void Rule40() {

	}
	/**	Rule41 is defined for the UNL Relation:
	 * 	'icl'.
	 * 	The 'icl' relation is obtained by applying the 
	 * 	Rule: <"உள்ளிட்ட","உள்பட","உட்பட">
	 */	
	public void Rule41() {
		rootrel.set(j, "icl");
		rel_label = "icl";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule42 is defined for the UNL Relation:
	 * 	'obj'.
	 * 	The 'obj' relation is obtained by applying the 
	 * 	Rules:<"என","என்று">
	 */
	
	public void Rule42() {
		rootrel.set(j, "obj");
		rel_label = "obj";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule43 is defined for the UNL Relation:
	 * 	'int'.
	 * 	The 'int' relation is obtained by applying the 
	 * 	Rule:<"இடையில்","இடையே>
	 */
	public void Rule43() {
		rootrel.set(j, "int");
		rel_label = "int";
		findRelation_Category4(j, rel_label);
	}
	/**	Rule44 is defined for the UNL Relation:
	 * 	'aoj'.
	 * 	The 'aoj' relation is obtained by applying the 
	 * 	Rule:
	 */
/**	public void Rule44() {
		rootrel.set(j, "aoj");
		rel_label = "aoj";
		findRelation_Category4(j, rel_label);
	}	*/

	public void Rule45() {

		// total=anal.size();

		// rootrel.add("None");
		// u_word = uw.get(j).toString();
		// ////System.out.println("U_WORD"+u_word);
		// if ((u_word.indexOf("place") != -1) || (u_word.indexOf("city") !=
		// -1)) {
		// ////System.out.println("Inside Switch While Rule45");
		// Rule38();
		// rel_label = "plc";
		// ////System.out.println("BALAJI RULE 45^^^^^^^^^^^^^^^^^^");
		// findRelation_Category2(j,rel_label);
		// }
	}
	/**	Rule46 is defined for the UNL Relation:
	 * 	'seq'.
	 * 	The 'seq' relation is obtained by applying the
	 * 	Rule:
	 */

/**	public void Rule46() {
		rootrel.set(j, "seq");
		rel_label = "seq";
		findRelation_Category1(j, rel_label);
	}	*/
	/**	Rule47 is defined for the UNL Relation:
	 * 	'coo'.
	 * 	The 'coo' relation is obtained by applying the 
	 * 	Rule: "போதிலும்".
	 */
	public void Rule47() {
		rootrel.set(j, "coo");
		rel_label = "coo";
		findRelation_Category1(j, rel_label);
	}

/**	public void Rule48() {

		total = anal.size();

		while (j < total) {
			try {
				rootrel.add("None");
				analysed = anal.get(j).toString().trim();

				if (analysed.indexOf("இல்") != -1) // il
				{

					if ((analysed.indexOf("இருந்து") != -1)) // irundhu
					{

						int i;
						for (i = j + 1; i < total; i++) {
							u_word = uw.get(j).toString();

							if ((u_word.indexOf("place") != -1)
									|| (u_word.indexOf("city") != -1)) {

								rootrel.set(i, "plt");

							}

						}
						rel_label = "plt";
						findRelation_Category3(i, rel_label);
					}
				}
			} catch (Exception e) {
			}
			j++;
		}
		j = 0;
	}	*/
	/**	Rule49 is defined for the UNL Relation:
	 * 	'plt'.
	 * 	The 'plt' relation is obtained by checking the uword constraint: 
	 * 	"place".
	 * 	Even if the 'plf' will obtained by <"இல்","இருந்து">, its not necessary that when the 'plt'
	 *	relation will comes with <"க்கு">.
	 */
	public void Rule49() {

		u_word = uw.get(j).toString();
		if (u_word.indexOf("place") != -1) {
			rootrel.set(j, "plt");
			int i;
			if ((j + 1) != total) {
				if (analysed.indexOf("இல்") != -1) // il
				{
					if ((analysed.indexOf("இருந்து") != -1)) // irundhu
					{
						rootrel.set(j, "plt");
						rel_label = "plt";
						findRelation_Category4(j, rel_label);
					}
				}
			}
		}
	}
	/**	Rule50 is defined for the UNL Relation:
	 * 	'pof'.
	 * 	The 'pof' relation is obtained by applying the
	 * 	Rule:"number".
	 * 	If the number street no.,door no.,etc.
	 * 	The condition is checked for the number not comes as a year, date, etc..
	 */
	public void Rule50() {
		if ((j - 1) != total) {
			u_word = uw.get(j - 1).toString();
			if (u_word.indexOf("place") != -1) {
				tempword = root.get(j + 1).toString().trim();

				if (!((tempword.equals("ஆம்")) || (tempword.equals("இல்"))
						|| (tempword.equals("ம்")) || (tempword.equals("ல்")))){		
					rootrel.set(j, "pof");
					rel_label = "pof";
					findRelation_Category5(j, j - 1, rel_label);
				}
			}
		}
		/**
		 * if ((j - 2) != total) { tempword = root.get(j - 2).toString(); //
		 * ////System.out.println("BALA TEMPWORD TELEPHONE"); if
		 * (!((tempword.equals("அறை")) || (tempword .equals("வண்டி")))) { //
		 * ////System.out.println("JI JI JI"); rootrel.set(j, "pos"); //
		 * rel_label="pos"; // findRelation_Category5(j,j-2,rel_label); } }
		 */
	}
	/**	Rule53 is defined for the UNL Relation:
	 * 	'pos'.
	 * 	The 'pos' relation is obtained by applying the
	 * 	Rule: <"க்கு","உரிய">,"உள்ள".
	 */

	public void Rule53() {
		rootrel.set(j, "pos");
		rel_label = "pos";
		findRelation_Category5(j + 1, j, rel_label);
	}
	/** Rule54 is defined for the UNL Relation:
	 * 	'pof'.
	 * 	The 'pof' relation is obtained by applying the 
	 * 	Rule:"உட்பட்ட".
	 */
	public void Rule54()
	{
		rootrel.set(j, "pof");
		rel_label = "pof";
		findRelation_Category2(j, rel_label);
	}

	public void Rule55() // idam,irndhu
	{
/**		rootrel.set(j, "pos");
		rel_label = "pos";
		findRelation_Category5(j + 1, j, rel_label);	*/
	}

	public void Rule57() // idam,irndhu
	{
/**		rootrel.set(j, "pos");
		rel_label = "pos";
		findRelation_Category5(j + 1, j, rel_label);	*/
	}

	public void findrelnindex() // throws Exception
	{

		j = 0;

		String analysed;
		String tempword;

		String rel_label;
		String h_word = " ";
		String u_word = " ";

		total = anal.size();
		result += "[r]#";
		while (j < total) {
			try {
			//	////System.out.println("j:"+j);
				rootrel.add("None");
				analysed = anal.get(j).toString().trim();
				tempword = root.get(j).toString().trim();
				u_word = uw.get(j).toString();
				if ((analysed.indexOf("இல்") != -1)|| (analysed.indexOf("ஆக") != -1)
				|| (analysed.indexOf("இடம்") != -1)) {
					if ((analysed.indexOf("இருந்து") != -1)) {
					Rule1();
					}
					if (analysed.indexOf("உள்ள") != -1){
						Rule40();
					}
					if (analysed.indexOf("உம்") != -1) {
						Rule4();
					}else{
						Rule38();
					}
				}
				if (analysed.indexOf("உம்") != -1) {
					Rule4();
				}
				if ((analysed.indexOf("படு") != -1)
						&& (analysed.indexOf("அது") != -1)) {
					Rule5();
				}
				if (analysed.indexOf("ஆல்") != -1) {
					Rule6();
				}
				if (analysed.indexOf("உக்கு") != -1) {
					if (analysed.indexOf("ஆக") != -1) {
					Rule9();
					}
				}
				if ((analysed.indexOf("உடன்") != -1)
						|| (analysed.indexOf("ஓடு") != -1)) {
					Rule10();
				}
				if (analysed.indexOf("க்கு") != -1) {
					if (analysed.indexOf("உரிய") != -1){
						Rule53();
					}
					if (analysed.indexOf("உட்பட்ட") != -1) {
						Rule54();
					}
					if (analysed.indexOf("உம்") != -1){
						Rule4();
					}
					Rule16();
				}
				if (analysed.indexOf("ஐ") != -1) {
					Rule18();
				}
				if (analysed.indexOf("இன்") != -1) {
					Rule20();
				}
				if ((analysed.indexOf("உடைய") != -1)
						|| (analysed.indexOf("அது") != -1)) {
					Rule29();
				}
				if ((analysed.indexOf("ஆக") != -1)
						|| (analysed.indexOf("க்க") != -1)) {
					Rule30();
				}
				if ((tempword.equals("உள்ளது"))
						|| (tempword.equals("இருக்கும்"))
						|| (tempword.equals("உள்ளன"))
						|| (tempword.equals("நிறைந்தது"))
						|| (tempword.equals("ஆகும்"))
						|| (tempword.equals("உண்டு"))
						|| (tempword.equals("பற்றி")) 
						|| (tempword.equals("பற்றிய"))
						|| (analysed.indexOf("உள்ளது") != -1)
						|| (analysed.indexOf("இருக்கும்") != -1)
						|| (analysed.indexOf("உள்ளன") != -1)
						|| (analysed.indexOf("நிறைந்தது") != -1)
						|| (analysed.indexOf("ஆகும்") != -1)
						|| (analysed.indexOf("உண்டு") != -1)) {
					Rule37();
				}
				if ((analysed.indexOf("என") != -1) || (tempword.equals("என"))
						|| (tempword.equals("என்று"))) {
					Rule42();
				}
				if ((tempword.equals("மட்டுமல்லாமல்"))||(tempword.equals("மற்றும்")) || (tempword.equals("மேலும்"))) {
					Rule2();
				}
				if (tempword.equals("வழியாக")) {
					Rule3();
				}
				if ((tempword.equals("காட்டிலும்")) || (tempword.equals("விட"))) {
					Rule8();
				}
				if (tempword.equals("என்னும்")) {
					Rule14();
				}
				if ((tempword.equals("முதல்")) || (tempword.equals("இருந்து"))) {
					Rule15();
				}
				if ((tempword.equals("மூலம்")) || (tempword.equals("வைத்து"))
						|| (tempword.equals("உபயோகி"))
						|| (tempword.equals("கொண்டு"))) {
					Rule21();
				}
				if (tempword.equals("மிக")) {
					Rule23();
				}
				if ((tempword.equals("ஆகிய")) || (tempword.equals("போன்ற"))
						|| (tempword.equals("முதலிய"))) {
					Rule26();
				}
				if (tempword.equals("அதனால்")) {
					Rule32();
				}
				if ((tempword.equals("அப்புறம்"))
						|| (tempword.equals("முன்னால்"))||(tempword.equals("பின்னால்"))
						|| (tempword.equals("பின்னர்"))
						|| (tempword.equals("பின்பு")) ) {
					Rule33();
				}
				if ((tempword.equals("ஆம்")) || (tempword.equals("இல்"))
						|| (tempword.equals("ம்")) || (tempword.equals("ல்"))) {
					Rule34();
				}
				if ((tempword.equals("அல்லாத"))
						|| (tempword.equals("நீங்கலாக"))) {
					Rule39();
				}
				if (tempword.equals("என்பது")) {
					Rule11();
				}
				if ((tempword.equals("கொண்டே")) || (tempword.equals("அதேவேளை"))) {
					Rule12();
				}
				if ((tempword.equals("பொழுது")) || (tempword.equals("போது"))) {
					Rule13();
				}
				if (tempword.equals("வரை")) {
					Rule17();
				}
				if ((pr_res == true)
						&& ((pr.indexOf("இங்கு") != -1) || (pr.indexOf("அங்கு") != -1))) {
					Rule19();
				}
				if (tempword.indexOf("பொது") != -1) {
					Rule22();
				}
				if (((pr.indexOf("இங்கு") == -1))
						&& (analysed.indexOf("Adverb") != -1)) {
					Rule24();
				}
				if ((analysed.indexOf("Adjective") != -1)
						|| (analysed.indexOf("Adjectival Suffix") != -1)
						|| (analysed.indexOf("Adjectival Noun") != -1)) {
					Rule25();
				}
				if (tempword.equals("அல்லது")) {
					Rule27();
				}
				if (tempword.equals("முறை")) {
					Rule28();
				}
				if (tempword.equals("நிறைய")) {
					Rule31();
				}
				if ( (tempword.equals("நாடு")) || (tempword.equals("மாவட்டம்")) || (tempword.equals("நகரம்")) || (tempword.equals("மாநிலம்")) || (tempword.equals("நதி")) || (tempword.equals("ஏரி")) || (tempword.equals("பாலம்")) ) {
					Rule35();
				}
				if ( (tempword.equals("உடல்")) || (tempword.equals("மரம்")) ){
					Rule36();
				}
				if ((tempword.equals("உள்ளிட்ட")) || (tempword.equals("உள்பட"))
						|| (tempword.equals("உட்பட"))) {
					Rule41();
				}
				if ((tempword.equals("இடையில்")) || (tempword.equals("இடையே"))) {
					Rule43();
				}
			/**	if ((tempword.equals("பற்றி")) || (tempword.equals("பற்றிய"))) {
					Rule37();
				}
				if ((tempword.equals("பின்னால்"))
						|| (tempword.equals("பின்னர்"))
						|| (tempword.equals("பின்பு"))) {
					Rule33();
				}	*/
				if (tempword.equals("போதிலும்")) {
					Rule47();
				}
				if (u_word.indexOf("place") != -1) {
					Rule49();
				}
				if (u_word.indexOf("number") != -1) {
					Rule50();
				}
				if (tempword.equals("உள்ள")) {
					Rule53();
				}
			/**	if (analysed.indexOf("இடம்") != -1) {
					Rule53();
				}	*/
				if ((tempword.equals("மட்டுமல்லாமல்"))
						|| (tempword.equals("அல்லாத"))) {
					Rule38();
				}
			} catch (Exception e) {
			}
			j++;
		}
		j = 0;	
    	       	//to find aoj,agt
    		//lexical end none + aojindex - aoj
     		//lexical end none + not aoj index - agt
	
     	for(int i = 0 ; i<uw.size() ; i++)
     	{
          	if((rootrel != null)&& (rootrel.size() >0)&&(rootrel.get(i).toString()).equals("None"))
            	{
	     		u_word = uw.get(i).toString();
		        if( (u_word.indexOf("person")!=-1) || (u_word.indexOf("food")!=-1) || (u_word.indexOf("vehicle")!=-1) ||(u_word.indexOf("machine")!=-1) || (u_word.indexOf("body")!=-1) || (u_word.indexOf("place")!=-1))            	
            		 {
             			if(aojindex > 0)
             			{
               				rel_label = "aoj";
             					findRelation_Category5(aojindex,i,rel_label);
             				break;
          		   	}
             			else if(uw.indexOf("icl>occupation") != -1)
             			{
               				rel_label = "aoj";
             					findRelation_Category5(uw.indexOf("icl>occupation"),i,rel_label);
             				break;
          		   	}
             			else
             			{
               			/*	rel_label = "agt";
             				findRelation_Category3(i,rel_label);
             				break;	*/
          		   	}
            		}
            	}
      }
            result  += "[/r]#[/s]#";
}
		

		
	public void findRelation_Category1(int j,String rl)
	{		String concept1=" ";
    			String concept2=" ";
		try
		{
			cnt1++;
    			int tot = hw.size();
			
			if( (rl.equals("cond")) || (rl.equals("rsn")))
			{
			
			}
			else
			{
				int size=no.size();
				if(size!=(j+1))
				{	
					concept1 = no.get(j+1).toString();
					////System.out.println( "concept1 " + concept1);
					if((j-1)> 0){
						concept2 = no.get(j-1).toString();
					}else 
					{
					concept2 = no.get(0).toString();
					}		
					////System.out.println( "concpt2 " );
						result += concept1 + '\t'+ rl + '\t' + concept2 + '#';
					 ////////////System.out.println( "result " + result);
				}
			}//System.out.println("Category1:"+cnt1);

		}
		catch(Exception e)
		{
		//	//System.out.println(no.size()+"and "+j);
		//	//System.out.println( "concept1 " + concept1);
			e.printStackTrace();
		}
	}
	public void findRelation_Category2(int j,String rl)
	{
		try
		{
			cnt2++;	////////////System.out.println("Inside Category2");
			
			String concept1=" ";
    		String concept2=" ";

			concept1 = verbno1;
        	concept2 = no.get(j ).toString();
        	result += concept1 + '\t'+ rl + '\t' + concept2+ '#';
		//System.out.println("Category2:"+cnt2);
    	}
   		catch(Exception e)
		{
		}
	}
	public void findRelation_Category3(int j,String rl)	
	{
			////////////System.out.println("Inside Category3");
	//	ArrayList root= new ArrayList();;
		try
		{
			cnt3++;
			String concept1=" ";
    		String concept2=" ";

    		int temp_i = root.indexOf(verb1);

    		//String uword = uw.get(no.indexOf(verbno1)).toString();

    		String uword = uw.get(temp_i).toString();

    		if((uword.indexOf("icl>do") != -1) || (uword.indexOf("agt<thing") != -1))
    		{
	
    				concept1 = verbno1;
            		concept2 = no.get(j ).toString();
            		result += concept1 + '\t'+ rl + '\t' + concept2+ '#';
    		}
    		else if(cobindex == 1)
    		{

    			concept1 = verbno1;
            	concept2 = no.get(j ).toString();
            	result += concept1 + '\t'+ "cob" + '\t' + concept2+ '#';
    		}//System.out.println("Category3:"+cnt3);
 		}
 		catch(Exception e)
		{
		}
	}
	public void findRelation_Category4(int j,String rl)
	{
		try
		{
			cnt4++;
			String concept1=" ";
    		String concept2=" ";

			concept1 = verbno1;
			////////////System.out.println("Concept Value1"+concept1);
	  if((j-1) >0){ 
    	    concept2 = no.get(j-1 ).toString();
	 } else
	{
	concept2 = no.get(0).toString();	
	}		
    	    ////////////System.out.println("Concept Value2"+concept2);
        	result += concept1 + '\t'+ rl + '\t' + concept2+ '#';
		//System.out.println("Category4:"+cnt4);
     	}
	    catch(Exception e)
		{
		}
	}
	public void findRelation_Category5(int i,int j,String rl)
	{
		try
		{
			cnt5++;
			String concept1=" ";
    		String concept2=" ";
			if(i > 0)
			concept1 = no.get(i).toString();
			else
			concept1 =no.get(0).toString();
	  if(j>0)		
    	    concept2 = no.get(j).toString();
	  else
		{
		if(i<0)
		{
		concept2 = "";
		}else
		concept2 = no.get(0).toString();
		}	   	
	

    	    result += concept1 + '\t'+ rl + '\t' + concept2+ '#';
		//System.out.println("Category5:"+cnt5);
   		}
     	catch(Exception e)
		{
		}
	}



public String translate(String st)
    {
    	String r_word = "";
    	String lex_end ="";
	init();
	StringTokenizer inp = new StringTokenizer(st,";");
        
        int noofpairs = inp.countTokens();
        int ctnoofpairs=0;
	if(noofpairs >1){
        while(ctnoofpairs < noofpairs)
	{

	
        	String word = inp.nextToken().trim();
	StringTokenizer inp1 = new StringTokenizer(word);

			if(inp1.countTokens() == 2)
			{

				r_word = inp1.nextToken().trim();
				lex_end = inp1.nextToken().trim();
			}
			else
			{
				r_word = inp1.nextToken().trim();
				lex_end = "None";
			}
			//////////System.out.println(r_word +"Debugging "+ lex_end);
				
			
          //to add root word arrayList
         
            root.add(r_word);
		if(!lex_end.equals("None"))
            anal.add(lex_end);

			ctnoofpairs++;

		
		}
		verb1 = root.get(root.size()-1).toString().trim(); 
	}else{
			StringTokenizer strToken = new StringTokenizer(st," ");
			if(strToken.countTokens() >1)
				enconvert1(st);
			else{
				enconvert1(st);
			        	findUW();				
	              			findrelnindex(); 	
				return result;
				
			}	
			StringTokenizer str = new StringTokenizer(st," ");
			while(str.hasMoreTokens())
			{
				enconvert1(str.nextToken());
			}
		        	findUW();

			while(true){
			if(strToken.countTokens()>1)
			{
				strToken.nextToken();
				String word2="";
				while(strToken.hasMoreTokens())
				{
					word2 = word2+strToken.nextToken() +" ";
				}	
				enconvert1(word2);
				strToken = new StringTokenizer(word2," ");
			}else
				break;
			}
			if(bolverb1 == true)
		        	verbno1 = findverbnumber(verb1);
		       	firstword=root.get(0).toString(); // to keep track of prev first word for PR
			firstwordpss=pos.get(0).toString();
       			findrelnindex();
		return result;
               }
         //to write words,pos,root in file

            
         findUW();
        // //////////System.out.println("Find UW "+result);	
         verbno1 = findverbnumber(verb1);
         ////////////System.out.println("Verb"+verb1);
         ////////////System.out.println("Verb Number"+verbno1);

         findrelnindex();
         ////////////System.out.println("Find Rel "+result);	
    return result;
  }

	public void enconvert1(String st)
	{
	    	try
	    	{
	    		int cnt=1;
			String templex="";
	       		int flag=0;
			int now =0;	
				
			//no. of words is initialized to zero
			//To initialize all array list, variables...
				//init();

	       //Identify words delimiter

				StringTokenizer inp = new StringTokenizer(st,", ");
				sente =  st;
				int noofwords = inp.countTokens();			// No. of words in the given input
				int ctnoofwords=0;							//Count no. of words is initialized to zero

		     //store the words in inp array List and root words in root array List

	    	    	while(ctnoofwords < noofwords)			//Check the condition
		    	{

		       		String word = inp.nextToken().trim(); // Remove the blank spaces in front and back of the sentence using trim().
	    	        		String pss="";
	       	        		String word2="";
	       	     			String word1="";
		    			String prev,next;

		  //to add root word in wordAL arrayList
					wordAL.add(word);

		  //analyze the given word

					String analysed  =	org.apache.nutch.analysis.unl.ta.Analyser.analyseF(word,true);
		  		StringTokenizer strToken2 = new StringTokenizer(analysed, ":\n<>,=*;:?-'\"&",false);
	    	       
				int firstindex= analysed.indexOf('<',analysed.indexOf('>'));
					String analmod = analysed.substring(firstindex);
					////System.out.println(analysed);		
		    	//to store analyzer output
							//to get root word and POS from analyzer output
				if((analysed.indexOf("unknown") != -1) || (analysed.indexOf("count=3") != -1))
				{			
					word1 = strToken2.nextToken().trim();
					word2 = word1;
					if(!root.contains(word2))
					{				
						pos.add("None");
						root.add(word2);
						anal.add(analmod);
					}
				}
				else if ((analysed.indexOf("Adjectival Noun") != -1) || (analysed.indexOf("Noun") != -1) ||(analysed.indexOf("Interrogative") != -1)  || (analysed.indexOf("Non Tamil Noun") != -1)|| (analysed.indexOf("Entity") !=-1) || (analysed.indexOf("Adverb") != -1) || (analysed.indexOf("Numbers") != -1) || (analysed.indexOf("charNumbers") != -1) || (analysed.indexOf("DateTime") != -1) || (analysed.indexOf("Postposition") != -1) ||((analysed.indexOf("Verb") != -1)&&(analysed.indexOf("Finite Verb")== -1))|| (analysed.indexOf("Particle") != -1) || (analysed.indexOf("Adjective") != -1))
				{
						
					prev = strToken2.nextToken().trim();
					word1 = prev;
					next = strToken2.nextToken().trim();	
					////////////System.out.println("NEXT:"+next);			
					while(strToken2.hasMoreTokens())
					{
						if ( (!(next.equals("Adjectival Noun"))) && (!(next.equals("Noun"))) && (!(next.equals("Interrogative Adjective"))) && (!(next.equals("Interrogative Noun"))) && (!(next.equals("Non Tamil Noun"))) && (!(next.equals("Entity"))) && (!(next.equals("Adverb"))) && (!(next.equals("Numbers"))) && (!(next.equals("charNumbers"))) && (!(next.equals("DateTime"))) && (!(next.equals("Postposition"))) && (!(next.equals("Verb"))) && (!(next.equals("Finite Verb"))) && (!(next.equals("Adjective"))) && ((!(next.equals("Particle")))))
						{
					
							prev = next;
							next = strToken2.nextToken().trim();
							////////////System.out.println("The VB is"+next);
						}
						else
						{
							break;
						}
					}
					word2 = prev;
					pss = next;
					////System.out.println(word2 +"  "+pss);
					if(word1.indexOf("இங்கு")!=-1)
		    	    		{			
					   	processPronoun(word1,ctnoofwords,firstwordpss,analmod);	
		        		}
		        		else
		        		{
						if(!root.contains(word2)){
		        	  			root.add(word2);
		        	   			pos.add(pss);
						anal.add(analmod);
						}

		        		}
		        		
					} 
				else
				{
					word1 = strToken2.nextToken().trim();
					word2 = strToken2.nextToken().trim();
					pss = strToken2.nextToken().trim();
					if((pss.equals("Pronoun")) || (word1.indexOf("இதன்")!=-1)) //ithan, ithu
	    	        		{
			        				processPronoun(word1,ctnoofwords,firstwordpss,analmod);	
	    	            		}
					else
					{
						if(!root.contains(word2))
						{
					  		root.add(word2);
			        			pos.add(pss);
							anal.add(analmod);
		
						}
		    	    		}
		    	 	} // end of else
			 	if((pss.equals("Verb")) || (pss.equals("Finite Verb")))
		     	 	{
					verbcount++;
		        			flag = 0;
					if(bolverb1==false)
		        		{
		        				bolverb1 = true;
		        				verb1 = word2;
		        		}
		        		else if((bolverb1==true) && (bolverb2 == false))
		        		{
		        				bolverb2 = true;
		        				verb2 = word2;              
		        		}
		        		else if((bolverb1==true) && (bolverb2==true) && (bolverb3 ==false))
		        		{
		        				bolverb3 = true;
		        	   			verb3 = word2;                 
		        		}
		     	 	} // end of if
		      	 	else
		      		{
		      			if(flag == 0)
		      			{
		        			int hc = word2.hashCode();
						////////////System.out.println("Hc  + Word2:"+hc +" "+word2);	
		        		//Set the unique value for the word using the Hashcode to search the word in the dictionary using the keyvalue
		        	    		if( (bn_mw = dict_mw.search(hc)) != null) // Condition is checked
		        	    		{
		        	    			////////////System.out.println("Matching");
						        	flag = 1;
		          					cnt++;
			        	    			now =bn_mw.no_words;
			        	    			templex += word2 + " ";
	    	        	        	}
				         }
				         else if((flag == 1) && (cnt < now))
	    	        	     	{
			           				cnt++;
		    	       				templex +=word2 + " ";            	       	
		    		     	}
				        else if((flag==1) && (cnt == now))
	    	        	     	{
			            				templex +=word2;
	   	                	        multiwordCheck1(templex,bn_mw,cnt,now,pss,analmod);
		          				templex="";
		          				cnt=1;
		           				flag=0;
		        	  	 } //end of else if
			        } // end of else
				sword=word2;
			

		      	 	////////////System.out.println("SWORD:"+sword);
		      	 	//ws.disambiguate(sword,bn,dict,sente);  
				ctnoofwords++;
			} // end of while
	       	}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}

}


